package gtag

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"strings"
)

type GenerateResult struct {
	Content []byte
	Output  string
}

func Generate(ctx context.Context, file, name string) (*GenerateResult, error) {
	f, err := loadFile(file)
	if err != nil {
		return nil, err
	}

	fields, err := parseStructField(f, name)
	if err != nil {
		return nil, err
	}

	if f.Name == nil {
		return nil, fmt.Errorf("can not find package name")
	}
	pkg := f.Name.Name

	buffer := &bytes.Buffer{}

	fmt.Fprintf(buffer, "// Code generated by gtag. DO NOT EDIT.\n")
	fmt.Fprintf(buffer, "// See: https://github.com/wolfogre/gtag\n\n")

	fmt.Fprintf(buffer, "//go:generate gtag\n")

	fmt.Fprintf(buffer, "package %s\n", pkg)

	fmt.Fprintf(buffer, "import \"reflect\"\n")

	fmt.Fprintf(buffer, "var (\n")
	fmt.Fprintf(buffer, "valueOf%s = %s{}\n", name, name)
	fmt.Fprintf(buffer, "typeOf%s = reflect.TypeOf(valueOf%s)\n\n", name, name)
	for _, field := range fields {
		fmt.Fprintf(buffer, "_ = valueOfUser.%s\n", field)
		fmt.Fprintf(buffer, "fieldOf%s%s, _ = typeOf%s.FieldByName(\"%s\")\n", name, field, name, field)
		fmt.Fprintf(buffer, "tagOf%s%s = fieldOf%s%s.Tag\n\n", name, field, name, field)

	}
	fmt.Fprintf(buffer, ")\n")

	fmt.Fprintf(buffer, "type %sTags struct {\n", name)
	for _, field := range fields {
		fmt.Fprintf(buffer, "\t%s string\n", field)
	}
	fmt.Fprintf(buffer, "}\n")

	fmt.Fprintf(buffer, "func (%s) Tags(tag string) %sTags {\n", name, name)
	fmt.Fprintf(buffer, "return %sTags{\n", name)
	for _, field := range fields {
		fmt.Fprintf(buffer, "%s: tagOf%s%s.Get(tag),\n", field, name, field)
	}
	fmt.Fprintf(buffer, "}\n}\n")

	src, err := format.Source(buffer.Bytes())
	if err != nil {
		return nil, err
	}

	ret := &GenerateResult{
		Content: src,
		Output:  strings.TrimSuffix(file, ".go") + "_tag.go",
	}

	if err := ret.Commit(); err != nil {
		return nil, err
	}

	return ret, nil
}

func (r *GenerateResult) Commit() error {
	if len(r.Content) == 0 {
		return nil
	}
	return ioutil.WriteFile(r.Output, r.Content, 0666)
}

func loadFile(name string) (*ast.File, error) {
	f, err := os.Open(name)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	return parser.ParseFile(token.NewFileSet(), name, f, 0)
}

func parseStructField(f *ast.File, name string) ([]string, error) {
	var fields []*ast.Field
	found := false

	ast.Inspect(f, func(n ast.Node) bool {
		if found {
			return false
		}
		switch t := n.(type) {
		case *ast.TypeSpec:
			if t.Name != nil && t.Name.Name == name {
				return true
			}
			return false
		case *ast.StructType:
			fields = t.Fields.List
			found = true
			return false
		}
		return true
	})

	if !found {
		return nil, fmt.Errorf("can not find struct %q", name)
	}

	var ret []string
	for _, field := range fields {
		for _, v := range field.Names {
			ret = append(ret, v.Name)
		}
	}

	return ret, nil
}
