package gtag

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"strings"
)

type GenerateResult struct {
	Content []byte
	Output  string
}

func Generate(ctx context.Context, file, name string) (*GenerateResult, error) {
	f, err := loadFile(file)
	if err != nil {
		return nil, err
	}

	fields, err := parseStructField(f, name)
	if err != nil {
		return nil, err
	}

	if f.Name == nil {
		return nil, fmt.Errorf("can not find package name")
	}
	pkg := f.Name.Name

	buffer := &bytes.Buffer{}

	fmt.Fprintf(buffer, "// Code generated by gtag. DO NOT EDIT.\n")
	fmt.Fprintf(buffer, "// See: https://github.com/gochore/gtag\n\n")

	fmt.Fprintf(buffer, "//go:generate gtag\n")

	fmt.Fprintf(buffer, "package %s\n", pkg)

	fmt.Fprintf(buffer, "import \"reflect\"\n")

	fmt.Fprintf(buffer, "func init() {\n")
	fmt.Fprintf(buffer, "\tv := User{}\n")
	for _, field := range fields {
		for _, fieldName := range field.Names {
			fmt.Fprintf(buffer, "\t_ = v.%s\n", fieldName.Name)
		}
	}
	fmt.Fprintf(buffer, "}\n")

	fmt.Fprintf(buffer, "var (\n")
	fmt.Fprintf(buffer, "typeOf%s = reflect.TypeOf(%s{})\n", name, name)
	fmt.Fprintf(buffer, ")\n")

	fmt.Fprintf(buffer, "type %sTags struct {\n", name)
	for _, field := range fields {
		for _, fieldName := range field.Names {
			fmt.Fprintf(buffer, "\t%s string\n", fieldName.Name)
		}
	}
	fmt.Fprintf(buffer, "}\n")

	fmt.Fprintf(buffer, "func (%s) Tags(tag string) %sTags {\n", name, name)
	fmt.Fprintf(buffer, "ret := %sTags{}\n", name)
	for _, field := range fields {
		for _, fieldName := range field.Names {
			fmt.Fprintf(buffer, "if f, ok := typeOf%s.FieldByName(\"%s\"); ok {\n", name, fieldName.Name)
			fmt.Fprintf(buffer, "ret.%s = f.Tag.Get(tag)\n}\n", fieldName.Name)
		}
	}
	fmt.Fprintf(buffer, "\treturn ret\n}\n")

	src, err := format.Source(buffer.Bytes())
	if err != nil {
		return nil, err
	}

	ret := &GenerateResult{
		Content: src,
		Output:  strings.TrimSuffix(file, ".go") + "_tag.go",
	}

	if err := ret.Commit(); err != nil {
		return nil, err
	}

	return ret, nil
}

func (r *GenerateResult) Commit() error {
	if len(r.Content) == 0 {
		return nil
	}
	return ioutil.WriteFile(r.Output, r.Content, 0666)
}

func loadFile(name string) (*ast.File, error) {
	f, err := os.Open(name)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	return parser.ParseFile(token.NewFileSet(), name, f, 0)
}

func parseStructField(f *ast.File, name string) ([]*ast.Field, error) {
	var fields []*ast.Field
	found := false

	ast.Inspect(f, func(n ast.Node) bool {
		if found {
			return false
		}
		switch t := n.(type) {
		case *ast.TypeSpec:
			if t.Name != nil && t.Name.Name == name {
				return true
			}
			return false
		case *ast.StructType:
			fields = t.Fields.List
			found = true
			return false
		}
		return true
	})

	if !found {
		return nil, fmt.Errorf("can not find struct %q", name)
	}

	return fields, nil
}
